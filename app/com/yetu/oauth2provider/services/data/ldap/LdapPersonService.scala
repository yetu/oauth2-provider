package com.yetu.oauth2provider.services.data.ldap

import com.unboundid.ldap.sdk.{ Attribute, Entry, Modification, ModificationType, SearchResultEntry }
import com.yetu.oauth2provider.controllers.authentication.providers.EmailPasswordProvider
import com.yetu.oauth2provider.data.ldap.LdapDAO
import com.yetu.oauth2provider.data.ldap.models.{ ClientPermission => LdapClientPermission, People }
import com.yetu.oauth2provider.oauth2.models._
import com.yetu.oauth2provider.services.data.interface.{ IMailTokenService, IPersonService }
import com.yetu.oauth2provider.signature.models.YetuPublicKey
import com.yetu.oauth2provider.utils._
import com.yetu.oauth2resource.model.ContactInfo
import securesocial.controllers.UserAgreement
import securesocial.core.providers.MailToken
import securesocial.core.services.{ SaveMode, UserService }
import securesocial.core.{ PasswordInfo, _ }

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.Future
import scala.util.Try

class LdapPersonService(dao: LdapDAO, mailTokenService: IMailTokenService) extends IPersonService with NamedLogger with UserService[YetuUser] {

  override def saveToken(token: MailToken): Future[MailToken] = {
    mailTokenService.saveToken(token)
  }

  override def deleteToken(uuid: String): Future[Option[MailToken]] = {
    mailTokenService.deleteToken(uuid)
  }

  override def findToken(token: String): Future[Option[MailToken]] = {
    mailTokenService.findToken(token)
  }

  override def deleteExpiredTokens(): Unit = {
    mailTokenService.deleteExpiredTokens()
  }

  override def updateUser(user: YetuUser) = {
    persistUserInfo(People.getDN(user.userId), user.firstName.get, user.lastName.get)
    persistContactInfo(People.getDN(user.userId), user.contactInfo.get)

    Future.successful(Some(user))
  }

  override def find(providerId: String, userId: String): Future[Option[BasicProfile]] = {
    findUser(userId)
  }

  override def findUser(userId: String) = {
    //For fetching operational attributes from LDAP (such as createdDateTime) just add "+" to search attributes
    val searchResult = dao.getEntry(People.getDN(userId),
      People.objectClassStr,
      People.USER_PASSWORD,
      People.EMAIL,
      People.LAST_NAME,
      People.FULL_NAME,
      People.FIRST_NAME,
      People.USER_PASSWORD,
      People.MEMBER_UID,
      People.CITY,
      People.MOBILE,
      People.HOME_PHONE,
      People.FAX,
      People.CHAT,
      People.HOUSE_NUMBER,
      People.COUNTRY,
      People.POSTAL_CODE,
      People.STREET,
      People.PHOTO,
      People.PUBLIC_KEY,
      People.USER_AGREEMENT,
      People.USER_AGREEMENT_DATE,
      "+")

    val result = searchResult match {
      case searchResult: SearchResultEntry => {

        try {
          //This value is generated by LDAP when we create an entity in LDAP
          val registrationDateLDAPFormat = searchResult.getAttribute("createTimestamp").getValue

          //Converting date to human readable formant
          val registrationDate = DateUtility.LDAPStringToDate(registrationDateLDAPFormat)

          //TODO temporary solution to avoid issues, THIS SHOULD BE FIXED
          var userPassword = searchResult.getAttribute(People.USER_PASSWORD).getValue
          userPassword = userPassword.replace("{CLEAR}", "")

          val contactInfo = createContactInfoObject(searchResult)

          val agreementOption: Option[UserAgreement] = for {
            agreement: String <- LDAPUtils.getAttribute(searchResult, People.USER_AGREEMENT)
            agreementDateString: String <- LDAPUtils.getAttribute(searchResult, People.USER_AGREEMENT_DATE)
            agreementDate = DateUtility.DateTimeFromString(agreementDateString)
          } yield UserAgreement(Try(agreement.toBoolean).getOrElse(false), agreementDate)

          val user = new YetuUser(
            userId,
            EmailPasswordProvider.EmailPassword,
            Some(searchResult.getAttribute(People.FIRST_NAME).getValue),
            Some(searchResult.getAttribute(People.LAST_NAME).getValue),
            Some(searchResult.getAttribute(People.FULL_NAME).getValue),
            Some(searchResult.getAttribute(People.EMAIL).getValue),
            None,
            AuthenticationMethod.UserPassword,
            None,
            None,
            Some(PasswordInfo("bcrypt", userPassword, None)),
            agreementOption,
            None,
            Some(contactInfo),
            LDAPUtils.getAttribute(searchResult, People.PUBLIC_KEY).map(key => YetuPublicKey(key))
          )

          Some(user)

        } catch {
          case e: NullPointerException => {
            logger.error(s"Nullpointer exception while calling find($userId): ${e.getMessage} \n ${e.getStackTrace}")
            // if we return None here, the user sees no error but has a broken system and cannot use his credentials nor register again
            // (as the save() method does not override if there is an existing entry.)
            // throw the error again so user is aware something is broken?
            throw (e)
          }
        }

      }
      case _ => None
    }

    Future.successful(result)
  }

  override def findByEmailAndProvider(email: String, providerId: String): Future[Option[BasicProfile]] = {
    findUser(email).map {

      case Some(u) =>
        if (u.providerId.equals(providerId)) {
          Some(u)
        } else None

      case _ => None
    }
  }

  override def deleteUser(id: String) = {
    Future.successful(dao.deleteEntry(People.getDN(id))).map(_ => Unit)
  }

  private def persistUserInfo(dn: String, firstName: String, lastName: String) = {
    //Update only firstname, lastname and fullname
    var mods = List[Modification]()
    mods = LDAPUtils.addToModList(mods, getModElement(People.FIRST_NAME, Some(firstName)))
    mods = LDAPUtils.addToModList(mods, getModElement(People.LAST_NAME, Some(lastName)))
    mods = LDAPUtils.addToModList(mods, getModElement(People.FULL_NAME, Some(firstName + " " + lastName)))
    dao.modify(dn, mods: _*)
  }

  private def persistContactInfo(dn: String, contactInfo: ContactInfo) = {
    var mods = List[Modification]()
    mods = LDAPUtils.addToModList(mods, getModElement(People.COUNTRY, contactInfo.country))
    mods = LDAPUtils.addToModList(mods, getModElement(People.STREET, contactInfo.street))
    mods = LDAPUtils.addToModList(mods, getModElement(People.HOUSE_NUMBER, contactInfo.houseNumber))
    mods = LDAPUtils.addToModList(mods, getModElement(People.POSTAL_CODE, contactInfo.postalCode))
    mods = LDAPUtils.addToModList(mods, getModElement(People.CITY, contactInfo.city))
    mods = LDAPUtils.addToModList(mods, getModElement(People.MOBILE, contactInfo.mobile))
    mods = LDAPUtils.addToModList(mods, getModElement(People.HOME_PHONE, contactInfo.homePhone))
    mods = LDAPUtils.addToModList(mods, getModElement(People.FAX, contactInfo.fax))
    mods = LDAPUtils.addToModList(mods, getModElement(People.CHAT, contactInfo.chat))

    dao.modify(dn, mods: _*)
  }

  override def addUser(user: YetuUser) = {

    val entry = new Entry(People.getDN(user.userId))
    entry.addAttribute(People.getObjectClass())
    entry.addAttribute(new Attribute(People.FIRST_NAME, user.firstName.get))
    entry.addAttribute(new Attribute(People.LAST_NAME, user.lastName.get))
    entry.addAttribute(new Attribute(People.FULL_NAME, user.fullName.get))
    entry.addAttribute(new Attribute(People.EMAIL, user.email.get))
    entry.addAttribute(new Attribute(People.USER_PASSWORD, user.passwordInfo.get.password))
    entry.addAttribute(new Attribute(People.MEMBER_UID, user.userId))
    user.userAgreement.map { agreement =>
      entry.addAttribute(new Attribute(
        People.USER_AGREEMENT,
        agreement.acceptTermsAndConditions.toString()
      ))
      entry.addAttribute(new Attribute(
        People.USER_AGREEMENT_DATE,
        DateUtility.DateTimeToString(agreement.acceptTermsAndConditionsDate)
      ))
    }

    dao.persist(entry)
    findUser(user.userId)
  }

  private def modifyUserPassword(profile: BasicProfile): Future[Option[YetuUser]] = {

    logger.debug(s"Modify password for user ${profile.userId}")
    val passwordMod = new Modification(
      ModificationType.REPLACE,
      People.USER_PASSWORD,
      profile.passwordInfo.get.password)

    dao.modify(People.getDN(profile.userId), passwordMod)
    findUser(profile.userId)
  }

  def modifyUserPublicKey(userId: String, key: YetuPublicKey) = {

    val publicKeyModification = new Modification(
      ModificationType.REPLACE,
      People.PUBLIC_KEY,
      key.key)

    dao.modify(People.getDN(userId), publicKeyModification)
  }

  private def getModElement(attribute: String, value: Option[String]): Option[Modification] = {
    value match {
      case Some(value) if value != "" => Some(new Modification(ModificationType.REPLACE, attribute, value))
      case _                          => None
    }
  }

  /**
   *
   * @param ldapEntry
   * @return
   */
  private def createContactInfoObject(ldapEntry: SearchResultEntry): ContactInfo = {
    val country: Option[String] = LDAPUtils.getAttribute(ldapEntry, People.COUNTRY)
    val street: Option[String] = LDAPUtils.getAttribute(ldapEntry, People.STREET)
    val houseNumber: Option[String] = LDAPUtils.getAttribute(ldapEntry, People.HOUSE_NUMBER)
    val postalCode: Option[String] = LDAPUtils.getAttribute(ldapEntry, People.POSTAL_CODE)
    val city: Option[String] = LDAPUtils.getAttribute(ldapEntry, People.CITY)
    val mobile: Option[String] = LDAPUtils.getAttribute(ldapEntry, People.MOBILE)
    val homePhone: Option[String] = LDAPUtils.getAttribute(ldapEntry, People.HOME_PHONE)
    val fax: Option[String] = LDAPUtils.getAttribute(ldapEntry, People.FAX)
    val chat: Option[String] = LDAPUtils.getAttribute(ldapEntry, People.CHAT)
    ContactInfo(country, street, houseNumber, postalCode, city, mobile, homePhone, fax, chat)
  }

  /**
   * Currently not needed; not implemented properly!
   *
   * Links the current user to another profile
   *
   * @param current The current user instance
   * @param to the profile that needs to be linked to
   */
  override def link(current: YetuUser, to: BasicProfile): Future[YetuUser] = {
    logger.warn("called the LdapPersonService.link() method, which is NOT IMPLEMENTED.")
    Future.successful(current)
  }

  /**
   * Returns an optional PasswordInfo instance for a given user
   *
   * @param user a user instance
   * @return returns an optional PasswordInfo
   */
  override def passwordInfoFor(user: YetuUser): Future[Option[PasswordInfo]] = {
    Future.successful(user.passwordInfo)
  }

  /**
   * Saves a profile.  This method gets called when a user logs in, registers or changes his password.
   * This is your chance to save the user information in your backing store.
   *
   * @param profile the user profile
   * @param mode a mode that tells you why the save method was called
   */
  override def save(profile: BasicProfile, mode: SaveMode) = {
    val result = mode match {
      case SaveMode.LoggedIn       => findUser(profile.userId)
      case SaveMode.PasswordChange => modifyUserPassword(profile)
      case SaveMode.SignUp         => addUser(profile.asInstanceOf[YetuUser])
    }

    result.map(_.orNull)
  }

  /**
   * Updates the PasswordInfo for a given user
   *
   * @param user a user instance
   * @param info the password info
   * @return
   */
  override def updatePasswordInfo(user: YetuUser, info: PasswordInfo): Future[Option[BasicProfile]] = {
    modifyUserPassword(user.copyUser(passwordInfo = Some(info)))
  }
}
