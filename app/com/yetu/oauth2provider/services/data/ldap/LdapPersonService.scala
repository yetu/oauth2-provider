package com.yetu.oauth2provider.services.data.ldap

import com.unboundid.ldap.sdk.{ Attribute, Entry, Modification, ModificationType, SearchResultEntry }
import com.yetu.oauth2provider.data.ldap.LdapDAO
import com.yetu.oauth2provider.data.ldap.models.{ ClientPermission => LdapClientPermission, People }
import com.yetu.oauth2provider.models.DataUpdateRequest
import com.yetu.oauth2provider.oauth2.models._
import com.yetu.oauth2provider.services.data.interface.IPersonService
import com.yetu.oauth2provider.signature.models.YetuPublicKey
import com.yetu.oauth2provider.utils._
import com.yetu.oauth2resource.model.ContactInfo
import play.api.mvc.Result
import play.api.mvc.Results._
import securesocial.controllers.UserAgreement
import securesocial.core.services.SaveMode
import securesocial.core.{ PasswordInfo, _ }

import scala.concurrent.Future
import scala.util.Try

class LdapPersonService(dao: LdapDAO) extends IPersonService with NamedLogger {

  /**
   * * //This function updates user basic information and contact information in LDAP
   * @param yetuUser
   * @param request
   * @return
   */
  def updateUserProfile(yetuUser: YetuUser, request: DataUpdateRequest): Result = {
    val firstName = StringUtils.isFull(request.firstName) match {
      case true  => request.firstName.get
      case false => yetuUser.firstName
    }

    val lastName = StringUtils.isFull(request.lastName) match {
      case true  => request.lastName.get
      case false => yetuUser.lastName
    }

    persistUserInfo(People.getDN(yetuUser.identityId.userId), firstName, lastName)

    //Update contact info only if there are contact info exist
    request.contactInfo match {
      case Some(contInfo) => {
        persistContactInfo(People.getDN(yetuUser.identityId.userId), contInfo)
      }
      case None =>
    }
    NoContent
  }

  /**
   * Finds a SocialUser that maches the specified id
   *
   * @param providerId the provider id
   * @param userId the user id
   * @return an optional profile
   */
  override def find(providerId: String, userId: String): Future[Option[BasicProfile]] = {
    Future.successful {
      val yetuUser = findYetuUser(userId)
      yetuUser.map(_.toBasicProfile)
    }
  }

  /**
   * Finds a profile by email and provider
   *
   * @param email - the user email
   * @param providerId - the provider id
   * @return an optional profile
   */
  override def findByEmailAndProvider(email: String, providerId: String): Future[Option[BasicProfile]] = {
    Future.successful {
      val yetuUser = findYetuUser(email)
      yetuUser.map(_.toBasicProfile)
    }
  }

  /**
   * maybe: refactor this?
   *
   * @param userId
   * @return
   */
  override def findYetuUser(userId: String): Option[YetuUser] = {
    //For fetching operational attributes from LDAP (such as createdDateTime) just add "+" to search attributes
    val searchResult = dao.getEntry(People.getDN(userId),
      People.objectClassStr,
      People.USER_PASSWORD,
      People.EMAIL,
      People.LAST_NAME,
      People.FULL_NAME,
      People.FIRST_NAME,
      People.USER_PASSWORD,
      People.MEMBER_UID,
      People.CITY,
      People.MOBILE,
      People.HOME_PHONE,
      People.FAX,
      People.CHAT,
      People.HOUSE_NUMBER,
      People.COUNTRY,
      People.POSTAL_CODE,
      People.STREET,
      People.PHOTO,
      People.PUBLIC_KEY,
      People.USER_AGREEMENT,
      People.USER_AGREEMENT_DATE,
      "+")

    searchResult match {
      case searchResult: SearchResultEntry => {

        try {
          //This value is generated by LDAP when we create an entity in LDAP
          val registrationDateLDAPFormat = searchResult.getAttribute("createTimestamp").getValue

          //Converting date to human readable formant
          val registrationDate = DateUtility.LDAPStringToDate(registrationDateLDAPFormat)

          //TODO temporary solution to avoid issues, THIS SHOULD BE FIXED
          var userPassword = searchResult.getAttribute(People.USER_PASSWORD).getValue
          userPassword = userPassword.replace("{CLEAR}", "")

          val contactInfo = createContactInfoObject(searchResult)

          val agreementOption: Option[UserAgreement] = for {
            agreement: String <- LDAPUtils.getAttribute(searchResult, People.USER_AGREEMENT)
            agreementDateString: String <- LDAPUtils.getAttribute(searchResult, People.USER_AGREEMENT_DATE)
            agreementDate = DateUtility.DateTimeFromString(agreementDateString)
          } yield UserAgreement(Try(agreement.toBoolean).getOrElse(false), agreementDate)

          val user = YetuUser(IdentityId(userId, "userpass"),
            searchResult.getAttribute(People.MEMBER_UID).getValue,
            searchResult.getAttribute(People.FIRST_NAME).getValue,
            searchResult.getAttribute(People.LAST_NAME).getValue,
            searchResult.getAttribute(People.FULL_NAME).getValue,
            Some(searchResult.getAttribute(People.EMAIL).getValue),
            None, AuthenticationMethod("userPassword"), None, None,
            Some(PasswordInfo("bcrypt", userPassword, None)), Some(registrationDate), Some(contactInfo),
            LDAPUtils.getAttribute(searchResult, People.PHOTO),
            LDAPUtils.getAttribute(searchResult, People.PUBLIC_KEY).map(key => YetuPublicKey(key)),
            agreementOption
          )

          Some(user)

        } catch {
          case e: NullPointerException => {
            logger.error(s"Nullpointer exception while calling find($userId): ${e.getMessage} \n ${e.getStackTrace}")
            // if we return None here, the user sees no error but has a broken system and cannot use his credentials nor register again
            // (as the save() method does not override if there is an existing entry.)
            // throw the error again so user is aware something is broken?
            throw (e)
          }
        }

      }
      case _ => None
    }
  }

  override def deleteUser(email: String) = {
    dao.deleteEntry(People.getDN(email))
  }

  private def persistUserInfo(dn: String, firstName: String, lastName: String) = {
    //Update only firstname, lastname and fullname
    var mods = List[Modification]()
    mods = LDAPUtils.addToModList(mods, getModElement(People.FIRST_NAME, Some(firstName)))
    mods = LDAPUtils.addToModList(mods, getModElement(People.LAST_NAME, Some(lastName)))
    mods = LDAPUtils.addToModList(mods, getModElement(People.FULL_NAME, Some(firstName + " " + lastName)))
    dao.modify(dn, mods: _*)
  }

  private def persistContactInfo(dn: String, contactInfo: ContactInfo) = {
    var mods = List[Modification]()
    mods = LDAPUtils.addToModList(mods, getModElement(People.COUNTRY, contactInfo.country))
    mods = LDAPUtils.addToModList(mods, getModElement(People.STREET, contactInfo.street))
    mods = LDAPUtils.addToModList(mods, getModElement(People.HOUSE_NUMBER, contactInfo.houseNumber))
    mods = LDAPUtils.addToModList(mods, getModElement(People.POSTAL_CODE, contactInfo.postalCode))
    mods = LDAPUtils.addToModList(mods, getModElement(People.CITY, contactInfo.city))
    mods = LDAPUtils.addToModList(mods, getModElement(People.MOBILE, contactInfo.mobile))
    mods = LDAPUtils.addToModList(mods, getModElement(People.HOME_PHONE, contactInfo.homePhone))
    mods = LDAPUtils.addToModList(mods, getModElement(People.FAX, contactInfo.fax))
    mods = LDAPUtils.addToModList(mods, getModElement(People.CHAT, contactInfo.chat))

    dao.modify(dn, mods: _*)
  }

  def addNewUser(user: YetuUser): YetuUser = {

    val entry = new Entry(People.getDN(user.userId))
    entry.addAttribute(People.getObjectClass())
    entry.addAttribute(new Attribute(People.FIRST_NAME, user.firstName))
    entry.addAttribute(new Attribute(People.LAST_NAME, user.lastName))
    entry.addAttribute(new Attribute(People.FULL_NAME, user.fullName))
    entry.addAttribute(new Attribute(People.EMAIL, user.email.getOrElse("")))
    entry.addAttribute(new Attribute(People.USER_PASSWORD, user.passwordInfo.get.password))
    entry.addAttribute(new Attribute(People.MEMBER_UID, user.uid))
    user.userAgreement.map { agreement =>
      entry.addAttribute(new Attribute(
        People.USER_AGREEMENT,
        agreement.acceptTermsAndConditions.toString()
      ))
      entry.addAttribute(new Attribute(
        People.USER_AGREEMENT_DATE,
        DateUtility.DateTimeToString(agreement.acceptTermsAndConditionsDate)
      ))
    }

    dao.persist(entry)
    // the extra step of retrieving the user again from LDAP after storing it is necessary to
    // get some extra information such as registration date. Do not skip this step.
    //TODO: refactor somehow, this is prone to nullPointer Exceptions:
    findYetuUser(user.userId).get
  }

  private def modifyUserPassword(profile: BasicProfile) = {
    logger.debug(s"Modify password for user ${profile.userId}")
    val passwordMod = new Modification(ModificationType.REPLACE,
      People.USER_PASSWORD, profile.passwordInfo.get.password)
    dao.modify(People.getDN(profile.userId), passwordMod)
  }

  def modifyUserPublicKey(userId: String, key: YetuPublicKey) = {
    val publicKeyModification = new Modification(ModificationType.REPLACE,
      People.PUBLIC_KEY, key.key)

    dao.modify(People.getDN(userId), publicKeyModification)
  }

  private def getModElement(attribute: String, value: Option[String]): Option[Modification] = {
    value match {
      case Some(value) if value != "" => Some(new Modification(ModificationType.REPLACE, attribute, value))
      case _                          => None
    }
  }

  /**
   *
   * @param ldapEntry
   * @return
   */
  private def createContactInfoObject(ldapEntry: SearchResultEntry): ContactInfo = {
    val country: Option[String] = LDAPUtils.getAttribute(ldapEntry, People.COUNTRY)
    val street: Option[String] = LDAPUtils.getAttribute(ldapEntry, People.STREET)
    val houseNumber: Option[String] = LDAPUtils.getAttribute(ldapEntry, People.HOUSE_NUMBER)
    val postalCode: Option[String] = LDAPUtils.getAttribute(ldapEntry, People.POSTAL_CODE)
    val city: Option[String] = LDAPUtils.getAttribute(ldapEntry, People.CITY)
    val mobile: Option[String] = LDAPUtils.getAttribute(ldapEntry, People.MOBILE)
    val homePhone: Option[String] = LDAPUtils.getAttribute(ldapEntry, People.HOME_PHONE)
    val fax: Option[String] = LDAPUtils.getAttribute(ldapEntry, People.FAX)
    val chat: Option[String] = LDAPUtils.getAttribute(ldapEntry, People.CHAT)
    ContactInfo(country, street, houseNumber, postalCode, city, mobile, homePhone, fax, chat)
  }

  /**
   * Currently not needed; not implemented properly!
   *
   * Links the current user to another profile
   *
   * @param current The current user instance
   * @param to the profile that needs to be linked to
   */
  override def link(current: YetuUser, to: BasicProfile): Future[YetuUser] = {
    logger.warn("called the LdapPersonService.link() method, which is NOT IMPLEMENTED.")
    Future.successful(current)
  }

  /**
   * Returns an optional PasswordInfo instance for a given user
   *
   * @param user a user instance
   * @return returns an optional PasswordInfo
   */
  override def passwordInfoFor(user: YetuUser): Future[Option[PasswordInfo]] = {
    Future.successful(user.passwordInfo)
  }

  /**
   * Saves a profile.  This method gets called when a user logs in, registers or changes his password.
   * This is your chance to save the user information in your backing store.
   *
   * @param profile the user profile
   * @param mode a mode that tells you why the save method was called
   */
  override def save(profile: BasicProfile, mode: SaveMode): Future[YetuUser] = {

    val result: YetuUser = mode match {
      case SaveMode.LoggedIn => {
        //TODO: refactor somehow, this is prone to nullPointer Exceptions:
        findYetuUser(profile.userId).get
      }
      case SaveMode.PasswordChange => {
        modifyUserPassword(profile)
        findYetuUser(profile.userId).get //TODO: change this? Prone to Nullpointer Exceptions
      }
      case SaveMode.SignUp => {
        import UUIDGenerator._
        val user = YetuUserHelper.fromBasicProfile(profile, uuid())
        addNewUser(user)
      }

    }
    Future.successful(result)

  }

  /**
   * Updates the PasswordInfo for a given user
   *
   * @param user a user instance
   * @param info the password info
   * @return
   */
  override def updatePasswordInfo(user: YetuUser, info: PasswordInfo): Future[Option[BasicProfile]] = {
    Future.successful {
      val newUser = user.toBasicProfile.copy(passwordInfo = Some(info))
      modifyUserPassword(newUser)
      Some(newUser)
    }
  }
}
